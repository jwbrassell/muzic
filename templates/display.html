<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Display</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { 
            margin: 0;
            padding: 0;
            height: 100vh;
            background: #000;
            color: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #mainHeader {
            display: flex;
            align-items: center;
            padding: 20px;
            background: rgba(13, 110, 253, 0.1);
            border-bottom: 2px solid #0d6efd;
            justify-content: space-between;
        }

        #brandLogo, #brandLogoRight {
            width: 100px;
            height: auto;
        }

        #brandLogo {
            margin-right: 20px;
        }

        #brandLogoRight {
            margin-left: 20px;
        }

        .headerText {
            flex: 1;
            text-align: center;
        }

        #mainHeader h1 {
            margin: 0;
            font-size: 36px;
            color: #0d6efd;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #songTitle {
            margin-top: 10px;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #header {
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        body:hover #header {
            opacity: 1;
        }

        .controls {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .controls i {
            color: white;
            font-size: 24px;
            transition: color 0.3s ease;
        }

        .controls i:hover {
            color: #0d6efd;
        }

        #nowPlaying {
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #progressContainer {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #progressBar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            cursor: pointer;
            margin-bottom: 5px;
        }

        #progressFill {
            width: 0%;
            height: 100%;
            background: #0d6efd;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        #timeInfo {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        #nextUpContainer {
            margin-top: 5px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        #nextUpLabel {
            color: #0d6efd;
            margin-right: 5px;
        }

        #visualizerContainer {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            min-height: 0;
            width: 100%;
            display: flex;
        }

        #visualizer {
            width: 100%;
            height: 100%;
            flex: 1;
        }

        #marquee {
            padding: 10px 0;
            background: #0d6efd;
            color: white;
            white-space: nowrap;
            overflow: hidden;
        }

        .marquee-content {
            display: inline-block;
            animation: marquee 40s linear infinite;
            padding-left: 100%;
        }

        @keyframes marquee {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }

        #footer {
            padding: 15px;
            background: #212529;
            color: #0d6efd;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Fullscreen styles */
        :fullscreen {
            background-color: #000;
            width: 100vw;
            height: 100vh;
        }

        :-webkit-full-screen {
            background-color: #000;
            width: 100vw;
            height: 100vh;
        }

        /* Hide address bar in fullscreen */
        :fullscreen #mainHeader {
            margin-top: env(safe-area-inset-top);
        }

        :-webkit-full-screen #mainHeader {
            margin-top: env(safe-area-inset-top);
        }
    </style>
</head>
<body>
    <div id="mainHeader">
        <img src="/static/tapfornerd.jpg" alt="TapForNerd Logo" id="brandLogo">
        <div class="headerText">
            <h1>TapForNerd Radio</h1>
            <div id="songTitle"></div>
        </div>
        <img src="/static/tapfornerd_flipped.png" alt="TapForNerd Logo Flipped" id="brandLogoRight">
    </div>
    <div id="header">
        <div id="nowPlaying" style="display: none;"></div>
        <div class="controls">
            <i id="playPauseIcon" class="fas fa-play" style="cursor: pointer; margin: 0 10px;"></i>
            <i id="fullscreenIcon" class="fas fa-expand" style="cursor: pointer; margin: 0 10px;"></i>
        </div>
    </div>

    <div id="visualizerContainer">
        <canvas id="visualizer"></canvas>
    </div>

    <div id="progressContainer">
        <div id="progressBar">
            <div id="progressFill"></div>
        </div>
        <div id="timeInfo">
            <span id="currentTime">0:00</span>
            <span id="duration">0:00</span>
        </div>
        <div id="nextUpContainer">
            <span id="nextUpLabel">Next up:</span>
            <span id="nextUpSong"></span>
        </div>
    </div>

    <div id="marquee">
        <div class="marquee-content" id="marqueeText">
            Brought to you by subscribers of Tap For Nerd
        </div>
    </div>

    <div id="footer">
        TapForNerd Radio
    </div>

    <audio id="audioPlayer" style="display: none;"></audio>

    <script src="/static/js/visualizations/base.js"></script>
    <script src="/static/js/visualizations/bars.js"></script>
    <script src="/static/js/visualizations/circles.js"></script>
    <script src="/static/js/visualizations/waves.js"></script>
    <script src="/static/js/visualizer.js"></script>
    <script>
        const audioPlayer = document.getElementById('audioPlayer');
        let isRepeat = true;  // Default to repeat mode
        let isShuffle = false;
        audioPlayer.preload = 'auto';
        audioPlayer.loop = false;  // Ensure single song repeat is off
        const visualizer = new AudioVisualizer();
        
        // Format time in seconds to MM:SS format
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Update progress bar and time displays
        function updateProgress() {
            if (!audioPlayer.duration) return;
            
            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration;
            const progress = (currentTime / duration) * 100;
            
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('currentTime').textContent = formatTime(currentTime);
            document.getElementById('duration').textContent = formatTime(duration);
        }

        // Add click handler for progress bar
        document.getElementById('progressBar').addEventListener('click', (e) => {
            const progressBar = e.currentTarget;
            const clickPosition = (e.pageX - progressBar.offsetLeft) / progressBar.offsetWidth;
            audioPlayer.currentTime = clickPosition * audioPlayer.duration;
        });

        // Update progress every 100ms
        setInterval(updateProgress, 100);

        // Fetch and display next track info
        async function updateNextTrack() {
            try {
                const response = await fetch('/api/next-track');
                const data = await response.json();
                if (!data.error) {
                    const artist = data.artist.toLowerCase().includes('unknown artist') ? 'TapForNerd' : data.artist;
                    const cleanTitle = data.title.replace(/\.(mp3|wav|m4a|mp4|ogg|webm|flac|aac)$/i, '');
                    document.getElementById('nextUpSong').textContent = `${cleanTitle} - ${artist}`;
                } else {
                    document.getElementById('nextUpSong').textContent = 'End of playlist';
                }
            } catch (error) {
                console.error('Error fetching next track:', error);
                document.getElementById('nextUpSong').textContent = 'Unknown';
            }
        }

        function updatePlayPauseIcon() {
            const icon = document.getElementById('playPauseIcon');
            icon.classList.remove('fa-play', 'fa-pause');
            icon.classList.add(audioPlayer.paused ? 'fa-play' : 'fa-pause');
        }

        function togglePlay() {
            if (audioPlayer.paused) {
                playAudio();
            } else {
                pauseAudio();
            }
        }

        async function nextTrack() {
            try {
                if (!audioPlayer.paused) {
                    audioPlayer.pause();
                }

                audioPlayer.volume = 0;
                audioPlayer.src = '';
                audioPlayer.load();

                const response = await fetch('/api/next', { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                if (data.error) {
                    console.log('End of playlist reached or error:', data.error);
                    if (isRepeat) {
                        console.log('Repeat is on, restarting playlist');
                        await updateNowPlaying();
                    } else {
                        document.getElementById('nowPlaying').textContent = 'End of playlist';
                        audioPlayer.pause();
                        audioPlayer.src = '';
                        updatePlayPauseIcon();
                    }
                    return;
                }

                const artist = data.artist.toLowerCase().includes('unknown artist') ? 'TapForNerd' : data.artist;
                const cleanTitle = data.title.replace(/\.(mp3|wav|m4a|mp4|ogg|webm|flac|aac)$/i, '');
                document.getElementById('songTitle').textContent = `${cleanTitle} - ${artist}`;
                const newSrc = `/media/${encodeURIComponent(data.file_path.split('/').pop())}`;
                console.log('Setting new audio source:', newSrc);
                
                if (audioPlayer.src !== window.location.origin + newSrc) {
                    try {
                        audioPlayer.src = newSrc;
                        audioPlayer.load();
                        
                        await new Promise((resolve) => {
                            audioPlayer.addEventListener('loadedmetadata', resolve, { once: true });
                        });
                        
                        await visualizer.initialize(audioPlayer);
                        visualizer.switchVisualizer();
                        
                        const playResult = await playAudio();
                        if (playResult === null) {
                            console.log('Retrying playback...');
                            await new Promise(resolve => setTimeout(resolve, 100));
                            await playAudio();
                        }
                        
                        const fadeInInterval = setInterval(() => {
                            if (audioPlayer.volume < 0.9) {
                                audioPlayer.volume = Math.min(1, audioPlayer.volume + 0.1);
                            } else {
                                clearInterval(fadeInInterval);
                                audioPlayer.volume = 1;
                            }
                        }, 50);
                        
                        updatePlayPauseIcon();
                        updateNextTrack(); // Update next track info after changing tracks
                    } catch (error) {
                        console.error('Error during track initialization:', error);
                        audioPlayer.volume = 1;
                        await playAudio().catch(e => {
                            console.error('Final playback attempt failed:', e);
                            throw e;
                        });
                    }
                }
            } catch (error) {
                console.error('Error during track transition:', error);
                await new Promise(resolve => setTimeout(resolve, 2000));
                await updateNowPlaying().catch(console.error);
            }
        }

        async function updateNowPlaying() {
            try {
                const response = await fetch('/api/now-playing');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Now playing data:', data);
                
                if (data.error) {
                    console.log('No media playing:', data.error);
                    document.getElementById('nowPlaying').textContent = 'No media playing';
                    if (audioPlayer.src) {
                        audioPlayer.pause();
                        audioPlayer.src = '';
                        updatePlayPauseIcon();
                    }
                    if (isRepeat) {
                        console.log('Repeat is on, attempting to restart playlist');
                        const nextResponse = await fetch('/api/next', { method: 'POST' });
                        if (nextResponse.ok) {
                            const nextData = await nextResponse.json();
                            if (!nextData.error) {
                                console.log('Successfully restarted playlist');
                                return updateNowPlaying();
                            }
                        }
                    }
                } else {
                    const artist = data.artist.toLowerCase().includes('unknown artist') ? 'TapForNerd' : data.artist;
                    const cleanTitle = data.title.replace(/\.(mp3|wav|m4a|mp4|ogg|webm|flac|aac)$/i, '');
                    document.getElementById('songTitle').textContent = `${cleanTitle} - ${artist}`;
                    const newSrc = `/media/${encodeURIComponent(data.file_path.split('/').pop())}`;
                    console.log('Setting new audio source:', newSrc);
                    
                    if (audioPlayer.src !== window.location.origin + newSrc) {
                        audioPlayer.pause();
                        audioPlayer.volume = 0;
                        audioPlayer.src = newSrc;
                        audioPlayer.load();
                        
                        try {
                            await Promise.race([
                                new Promise((resolve) => {
                                    audioPlayer.addEventListener('loadedmetadata', resolve, { once: true });
                                }),
                                new Promise((_, reject) => setTimeout(() => reject(new Error('Metadata load timeout')), 5000))
                            ]);
                        } catch (error) {
                            console.error('Error loading metadata:', error);
                            audioPlayer.load();
                            await new Promise((resolve) => {
                                audioPlayer.addEventListener('loadedmetadata', resolve, { once: true });
                            });
                        }
                        
                        await visualizer.initialize(audioPlayer);
                        
                        const playResult = await playAudio();
                        if (playResult === null) {
                            console.log('Retrying playback...');
                            await new Promise(resolve => setTimeout(resolve, 100));
                            await playAudio();
                        }
                        
                        const fadeInInterval = setInterval(() => {
                            if (audioPlayer.volume < 0.9) {
                                audioPlayer.volume = Math.min(1, audioPlayer.volume + 0.1);
                            } else {
                                clearInterval(fadeInInterval);
                                audioPlayer.volume = 1;
                            }
                        }, 50);
                        
                        updatePlayPauseIcon();
                        updateNextTrack(); // Update next track info after loading current track
                    }
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }

        async function playAudio() {
            try {
                console.log('Starting audio playback...');
                
                if (!audioPlayer.src) {
                    console.log('No audio source set, fetching current track...');
                    await updateNowPlaying();
                    if (!audioPlayer.src) {
                        throw new Error('No audio source available');
                    }
                }
                
                if (!visualizer.isInitialized) {
                    await visualizer.initialize(audioPlayer);
                }
                
                if (visualizer.audioContext?.state === 'suspended') {
                    await visualizer.audioContext.resume();
                }
                
                const loadTimeout = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Audio load timeout')), 5000);
                });
                
                const canPlayPromise = new Promise((resolve) => {
                    if (audioPlayer.readyState >= 2) {
                        resolve();
                    } else {
                        audioPlayer.addEventListener('canplay', resolve, { once: true });
                    }
                });
                
                try {
                    await Promise.race([canPlayPromise, loadTimeout]);
                } catch (error) {
                    console.error('Audio loading error:', error);
                    await updateNowPlaying();
                    await new Promise((resolve) => {
                        audioPlayer.addEventListener('canplay', resolve, { once: true });
                    });
                }
                
                try {
                    const playPromise = audioPlayer.play();
                    await playPromise;
                    
                    updatePlayPauseIcon();
                    console.log('Audio playback started successfully');
                    return playPromise;
                } catch (playError) {
                    if (playError.name === 'AbortError') {
                        console.log('Playback was interrupted, will retry if needed');
                        return null;
                    }
                    throw playError;
                }
            } catch (e) {
                console.error('Playback error:', e);
                if (!isTransitioning) {
                    console.log('Attempting to recover by playing next track...');
                    await nextTrack().catch(console.error);
                }
                throw e;
            }
        }

        function pauseAudio() {
            console.log('Pausing audio...');
            audioPlayer.pause();
            updatePlayPauseIcon();
            if (visualizer) {
                visualizer.stop();
            }
        }

        let playbackMonitor;
        
        function startContinuousPlayback() {
            console.log('Starting continuous playback monitoring...');
            if (playbackMonitor) {
                clearInterval(playbackMonitor);
            }
            
            playbackMonitor = setInterval(() => {
                if (!audioPlayer.paused && !isTransitioning) {
                    updateNowPlaying();
                }
            }, 10000);
        }

        window.addEventListener('message', async (event) => {
            console.log('Received message:', event.data);
            if (event.data === 'play') {
                try {
                    console.log('Received play command');
                    await updateNowPlaying();
                    await playAudio();
                    startContinuousPlayback();
                } catch (error) {
                    console.error('Error starting playback:', error);
                    setTimeout(async () => {
                        await updateNowPlaying();
                        await playAudio();
                        startContinuousPlayback();
                    }, 1000);
                }
            } else if (event.data === 'pause') {
                pauseAudio();
            } else if (event.data === 'togglePlay') {
                if (audioPlayer.paused) {
                    await playAudio();
                } else {
                    pauseAudio();
                }
            } else if (event.data === 'mute') {
                audioPlayer.muted = true;
            } else if (event.data.type === 'updateText') {
                if (event.data.target === 'marquee') {
                    document.getElementById('marqueeText').textContent = event.data.text;
                } else if (event.data.target === 'footer') {
                    document.getElementById('footer').textContent = event.data.text;
                }
            }
        });

        let isTransitioning = false;
        audioPlayer.addEventListener('ended', async () => {
            if (isTransitioning) {
                console.log('Already transitioning, skipping duplicate ended event');
                return;
            }
            
            console.log('Audio ended, transitioning to next track...');
            isTransitioning = true;
            
            try {
                await nextTrack();
                if (!isRepeat) {
                    const response = await fetch('/api/now-playing');
                    const data = await response.json();
                    if (data.error) {
                        audioPlayer.pause();
                        audioPlayer.src = '';
                        updatePlayPauseIcon();
                    }
                }
            } catch (error) {
                console.error('Error during track transition:', error);
                setTimeout(nextTrack, 1000);
            } finally {
                setTimeout(() => {
                    isTransitioning = false;
                }, 500);
            }
        });

        document.getElementById('playPauseIcon').addEventListener('click', togglePlay);

        window.addEventListener('load', () => {
            startContinuousPlayback();
            updateNextTrack(); // Initial update of next track info
        });

        audioPlayer.addEventListener('error', (e) => {
            const error = audioPlayer.error;
            let errorMessage = 'Unknown error';
            
            if (error) {
                switch (error.code) {
                    case MediaError.MEDIA_ERR_ABORTED:
                        errorMessage = 'Playback aborted by user';
                        break;
                    case MediaError.MEDIA_ERR_NETWORK:
                        errorMessage = 'Network error while loading media';
                        break;
                    case MediaError.MEDIA_ERR_DECODE:
                        errorMessage = 'Media decoding error';
                        break;
                    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMessage = 'Media format not supported';
                        break;
                }
                console.error('Audio error:', errorMessage, error.message);
                
                if (error.code === MediaError.MEDIA_ERR_NETWORK) {
                    console.log('Attempting to recover from network error...');
                    setTimeout(async () => {
                        try {
                            await updateNowPlaying();
                        } catch (err) {
                            console.error('Recovery failed:', err);
                        }
                    }, 2000);
                }
            } else {
                console.error('Audio error event without error details:', e);
            }
        });

        function savePlaylistState() {
            fetch('/api/save-state', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Playlist state saved:', data);
                    const saveIcon = document.querySelector('.fa-save');
                    saveIcon.style.color = '#0d6efd';
                    setTimeout(() => {
                        saveIcon.style.color = 'white';
                    }, 500);
                })
                .catch(error => console.error('Error saving playlist state:', error));
        }

        // Fullscreen functionality
        const fullscreenIcon = document.getElementById('fullscreenIcon');
        
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen()
                    .then(() => {
                        fullscreenIcon.classList.remove('fa-expand');
                        fullscreenIcon.classList.add('fa-compress');
                    })
                    .catch(err => {
                        console.error('Error attempting to enable fullscreen:', err);
                    });
            } else {
                document.exitFullscreen()
                    .then(() => {
                        fullscreenIcon.classList.remove('fa-compress');
                        fullscreenIcon.classList.add('fa-expand');
                    })
                    .catch(err => {
                        console.error('Error attempting to exit fullscreen:', err);
                    });
            }
        }

        fullscreenIcon.addEventListener('click', toggleFullScreen);

        // Update fullscreen icon when fullscreen state changes
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                fullscreenIcon.classList.remove('fa-expand');
                fullscreenIcon.classList.add('fa-compress');
            } else {
                fullscreenIcon.classList.remove('fa-compress');
                fullscreenIcon.classList.add('fa-expand');
            }
        });
    </script>
</body>
</html>
