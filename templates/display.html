<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Display</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { 
            margin: 0;
            padding: 0;
            height: 100vh;
            background: #000;
            color: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #mainHeader {
            display: flex;
            align-items: center;
            padding: 20px;
            background: rgba(13, 110, 253, 0.1);
            border-bottom: 2px solid #0d6efd;
            justify-content: space-between;
        }

        #brandLogo, #brandLogoRight {
            width: 100px;
            height: auto;
        }

        #brandLogo {
            margin-right: 20px;
        }

        #brandLogoRight {
            margin-left: 20px;
        }

        .headerText {
            flex: 1;
            text-align: center;
        }

        #mainHeader h1 {
            margin: 0;
            font-size: 36px;
            color: #0d6efd;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #songTitle {
            margin-top: 10px;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #header {
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        body:hover #header {
            opacity: 1;
        }

        .controls {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .controls i {
            color: white;
            font-size: 24px;
            transition: color 0.3s ease;
        }

        .controls i:hover {
            color: #0d6efd;
        }

        #nowPlaying {
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #visualizerContainer {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            min-height: 0;
            width: 100%;
            display: flex;
        }

        #visualizer {
            width: 100%;
            height: 100%;
            flex: 1;
        }

        #marquee {
            padding: 10px 0;
            background: #0d6efd;
            color: white;
            white-space: nowrap;
            overflow: hidden;
        }

        .marquee-content {
            display: inline-block;
            animation: marquee 40s linear infinite;
            padding-left: 100%;
        }

        @keyframes marquee {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }

        #footer {
            padding: 15px;
            background: #212529;
            color: #0d6efd;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="mainHeader">
        <img src="/static/tapfornerd.jpg" alt="TapForNerd Logo" id="brandLogo">
        <div class="headerText">
            <h1>TapForNerd Radio</h1>
            <div id="songTitle"></div>
        </div>
        <img src="/static/tapfornerd_flipped.png" alt="TapForNerd Logo Flipped" id="brandLogoRight">
    </div>
    <div id="header">
        <div id="nowPlaying" style="display: none;"></div>
        <div class="controls">
            <i id="playPauseIcon" class="fas fa-play" style="cursor: pointer; margin: 0 10px;"></i>
        </div>
    </div>

    <div id="visualizerContainer">
        <canvas id="visualizer"></canvas>
    </div>

    <div id="marquee">
        <div class="marquee-content" id="marqueeText">
            Brought to you by subscribers of Tap For Nerd
        </div>
    </div>

    <div id="footer">
        TapForNerd Radio
    </div>

    <audio id="audioPlayer" style="display: none;"></audio>

    <script src="/static/js/visualizations/base.js"></script>
    <script src="/static/js/visualizations/bars.js"></script>
    <script src="/static/js/visualizations/circles.js"></script>
    <script src="/static/js/visualizations/waves.js"></script>
    <script src="/static/js/visualizer.js"></script>
    <script>
        const audioPlayer = document.getElementById('audioPlayer');
        let isRepeat = true;  // Default to repeat mode
        let isShuffle = false;
        audioPlayer.preload = 'auto';
        audioPlayer.loop = false;  // Ensure single song repeat is off
        const visualizer = new AudioVisualizer();
        
        function updatePlayPauseIcon() {
            const icon = document.getElementById('playPauseIcon');
            icon.classList.remove('fa-play', 'fa-pause');
            icon.classList.add(audioPlayer.paused ? 'fa-play' : 'fa-pause');
        }

        function togglePlay() {
            if (audioPlayer.paused) {
                playAudio();
            } else {
                pauseAudio();
            }
        }

        async function nextTrack() {
            try {
                // Pause current track immediately to prevent race conditions
                if (!audioPlayer.paused) {
                    audioPlayer.pause();
                }

                // Reset audio player state
                audioPlayer.volume = 0;
                audioPlayer.src = '';
                audioPlayer.load(); // Force reload to clear any error state

                const response = await fetch('/api/next', { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                if (data.error) {
                    console.log('End of playlist reached or error:', data.error);
                    if (isRepeat) {
                        console.log('Repeat is on, restarting playlist');
                        // Force a refresh of now playing to restart playlist
                        await updateNowPlaying();
                    } else {
                        document.getElementById('nowPlaying').textContent = 'End of playlist';
                        audioPlayer.pause();
                        audioPlayer.src = '';
                        updatePlayPauseIcon();
                    }
                    return;
                }

                const artist = data.artist.toLowerCase().includes('unknown artist') ? 'TapForNerd' : data.artist;
                const cleanTitle = data.title.replace(/\.(mp3|wav|m4a|mp4|ogg|webm|flac|aac)$/i, '');
                document.getElementById('songTitle').textContent = `${cleanTitle} - ${artist}`;
                const newSrc = `/media/${encodeURIComponent(data.file_path.split('/').pop())}`;
                console.log('Setting new audio source:', newSrc);
                
                if (audioPlayer.src !== window.location.origin + newSrc) {
                    try {
                        // Set and load new source
                        audioPlayer.src = newSrc;
                        audioPlayer.load(); // Force load to ensure proper state
                        
                        // Wait for metadata to load
                        await new Promise((resolve) => {
                            audioPlayer.addEventListener('loadedmetadata', resolve, { once: true });
                        });
                        
                        // Initialize visualizer
                        await visualizer.initialize(audioPlayer);
                        visualizer.switchVisualizer();
                        
                        // Start playback with volume 0
                        const playResult = await playAudio();
                        if (playResult === null) {
                            // Playback was interrupted, retry once
                            console.log('Retrying playback...');
                            await new Promise(resolve => setTimeout(resolve, 100));
                            await playAudio();
                        }
                        
                        // Fade in volume
                        const fadeInInterval = setInterval(() => {
                            if (audioPlayer.volume < 0.9) {
                                audioPlayer.volume = Math.min(1, audioPlayer.volume + 0.1);
                            } else {
                                clearInterval(fadeInInterval);
                                audioPlayer.volume = 1;
                            }
                        }, 50);
                        
                        updatePlayPauseIcon();
                    } catch (error) {
                        console.error('Error during track initialization:', error);
                        // If visualization fails, try one more time with just audio
                        audioPlayer.volume = 1;
                        await playAudio().catch(e => {
                            console.error('Final playback attempt failed:', e);
                            throw e;
                        });
                    }
                }
            } catch (error) {
                console.error('Error during track transition:', error);
                // Wait a bit longer before retrying
                await new Promise(resolve => setTimeout(resolve, 2000));
                await updateNowPlaying().catch(console.error);
            }
        }

        function toggleRepeat() {
            fetch('/api/toggle-repeat', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    isRepeat = data.repeat;
                    const icon = document.getElementById('repeatIcon');
                    icon.style.color = isRepeat ? '#0d6efd' : 'white';
                    // If we're at the end of the playlist and turning repeat on, restart
                    if (isRepeat && audioPlayer.ended) {
                        updateNowPlaying();
                    }
                    // Save state after toggling repeat
                    return fetch('/api/save-state', { method: 'POST' });
                })
                .catch(error => console.error('Error:', error));
        }

        function toggleShuffle() {
            fetch('/api/toggle-shuffle', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    isShuffle = data.shuffle;
                    const icon = document.getElementById('shuffleIcon');
                    icon.style.color = isShuffle ? '#0d6efd' : 'white';
                    // Save state after toggling shuffle
                    return fetch('/api/save-state', { method: 'POST' });
                })
                .catch(error => console.error('Error:', error));
        }

        function previousTrack() {
            // Add previous track functionality when backend supports it
            console.log('Previous track - Not implemented yet');
        }

        async function updateNowPlaying() {
            try {
                const response = await fetch('/api/now-playing');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Now playing data:', data);
                
                if (data.error) {
                    console.log('No media playing:', data.error);
                    document.getElementById('nowPlaying').textContent = 'No media playing';
                    if (audioPlayer.src) {
                        audioPlayer.pause();
                        audioPlayer.src = '';
                        updatePlayPauseIcon();
                    }
                    // If repeat is on and we have a playlist, try to restart it
                    if (isRepeat) {
                        console.log('Repeat is on, attempting to restart playlist');
                        const nextResponse = await fetch('/api/next', { method: 'POST' });
                        if (nextResponse.ok) {
                            const nextData = await nextResponse.json();
                            if (!nextData.error) {
                                console.log('Successfully restarted playlist');
                                // Recursively call to update with new track
                                return updateNowPlaying();
                            }
                        }
                    }
                } else {
                    const artist = data.artist.toLowerCase().includes('unknown artist') ? 'TapForNerd' : data.artist;
                    // Remove common audio/video extensions from title
                    const cleanTitle = data.title.replace(/\.(mp3|wav|m4a|mp4|ogg|webm|flac|aac)$/i, '');
                    document.getElementById('songTitle').textContent = `${cleanTitle} - ${artist}`;
                    const newSrc = `/media/${encodeURIComponent(data.file_path.split('/').pop())}`;
                    console.log('Setting new audio source:', newSrc);
                    
                    if (audioPlayer.src !== window.location.origin + newSrc) {
                        // Reset audio player state
                        audioPlayer.pause();
                        audioPlayer.volume = 0;
                        audioPlayer.src = newSrc;
                        audioPlayer.load(); // Force load to ensure proper state
                        
                        // Wait for metadata with timeout
                        try {
                            await Promise.race([
                                new Promise((resolve) => {
                                    audioPlayer.addEventListener('loadedmetadata', resolve, { once: true });
                                }),
                                new Promise((_, reject) => setTimeout(() => reject(new Error('Metadata load timeout')), 5000))
                            ]);
                        } catch (error) {
                            console.error('Error loading metadata:', error);
                            // Try one more time
                            audioPlayer.load();
                            await new Promise((resolve) => {
                                audioPlayer.addEventListener('loadedmetadata', resolve, { once: true });
                            });
                        }
                        
                        // Initialize visualizer if needed
                        await visualizer.initialize(audioPlayer);
                        
                        // Start playback
                        const playResult = await playAudio();
                        if (playResult === null) {
                            // Playback was interrupted, retry once
                            console.log('Retrying playback...');
                            await new Promise(resolve => setTimeout(resolve, 100));
                            await playAudio();
                        }
                        
                        // Fade in volume only after successful playback
                        const fadeInInterval = setInterval(() => {
                            if (audioPlayer.volume < 0.9) {
                                audioPlayer.volume = Math.min(1, audioPlayer.volume + 0.1);
                            } else {
                                clearInterval(fadeInInterval);
                                audioPlayer.volume = 1;
                            }
                        }, 50);
                        
                        updatePlayPauseIcon();
                    }
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }

        async function playAudio() {
            try {
                console.log('Starting audio playback...');
                
                // Check if we have a valid source
                if (!audioPlayer.src) {
                    console.log('No audio source set, fetching current track...');
                    await updateNowPlaying();
                    if (!audioPlayer.src) {
                        throw new Error('No audio source available');
                    }
                }
                
                // Initialize visualizer if not already done
                if (!visualizer.isInitialized) {
                    await visualizer.initialize(audioPlayer);
                }
                
                // Resume audio context if it exists and is suspended
                if (visualizer.audioContext?.state === 'suspended') {
                    await visualizer.audioContext.resume();
                }
                
                // Wait for audio to be ready with timeout
                const loadTimeout = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Audio load timeout')), 5000);
                });
                
                const canPlayPromise = new Promise((resolve) => {
                    if (audioPlayer.readyState >= 2) { // HAVE_CURRENT_DATA
                        resolve();
                    } else {
                        audioPlayer.addEventListener('canplay', resolve, { once: true });
                    }
                });
                
                try {
                    await Promise.race([canPlayPromise, loadTimeout]);
                } catch (error) {
                    console.error('Audio loading error:', error);
                    // Try to recover by reloading the track
                    await updateNowPlaying();
                    // Wait again for the audio to be ready
                    await new Promise((resolve) => {
                        audioPlayer.addEventListener('canplay', resolve, { once: true });
                    });
                }
                
                try {
                    // Start playback and return the promise
                    const playPromise = audioPlayer.play();
                    await playPromise;  // Wait for playback to actually start
                    
                    updatePlayPauseIcon();
                    console.log('Audio playback started successfully');
                    return playPromise;
                } catch (playError) {
                    // Handle abort errors gracefully
                    if (playError.name === 'AbortError') {
                        console.log('Playback was interrupted, will retry if needed');
                        // Don't throw for abort errors, as they're expected in some cases
                        return null;
                    }
                    throw playError; // Rethrow other errors
                }
            } catch (e) {
                console.error('Playback error:', e);
                // Try to recover by moving to next track
                if (!isTransitioning) {
                    console.log('Attempting to recover by playing next track...');
                    await nextTrack().catch(console.error);
                }
                throw e;  // Propagate error for handling by caller
            }
        }

        function pauseAudio() {
            console.log('Pausing audio...');
            audioPlayer.pause();
            updatePlayPauseIcon();
            if (visualizer) {
                visualizer.stop();
            }
        }

        // Initialize continuous playback system
        let playbackMonitor;
        
        function startContinuousPlayback() {
            console.log('Starting continuous playback monitoring...');
            // Clear any existing monitor
            if (playbackMonitor) {
                clearInterval(playbackMonitor);
            }
            
            // Start periodic monitoring with a longer interval
            playbackMonitor = setInterval(() => {
                if (!audioPlayer.paused && !isTransitioning) {
                    updateNowPlaying();
                }
            }, 10000); // Increased to 10 seconds to reduce interference
        }

        // Listen for messages from the admin page
        window.addEventListener('message', async (event) => {
            console.log('Received message:', event.data);
            if (event.data === 'play') {
                try {
                    console.log('Received play command');
                    // First update now playing to get the current track
                    await updateNowPlaying();
                    // Then start playback
                    await playAudio();
                    // Start continuous playback monitoring
                    startContinuousPlayback();
                } catch (error) {
                    console.error('Error starting playback:', error);
                    // Try again after a delay
                    setTimeout(async () => {
                        await updateNowPlaying();
                        await playAudio();
                        startContinuousPlayback();
                    }, 1000);
                }
            } else if (event.data === 'pause') {
                pauseAudio();
            } else if (event.data === 'togglePlay') {
                if (audioPlayer.paused) {
                    await playAudio();
                } else {
                    pauseAudio();
                }
            } else if (event.data === 'mute') {
                audioPlayer.muted = true;
            } else if (event.data.type === 'updateText') {
                if (event.data.target === 'marquee') {
                    document.getElementById('marqueeText').textContent = event.data.text;
                } else if (event.data.target === 'footer') {
                    document.getElementById('footer').textContent = event.data.text;
                }
            }
        });

        // Handle audio ended event with transition protection
        let isTransitioning = false;
        audioPlayer.addEventListener('ended', async () => {
            if (isTransitioning) {
                console.log('Already transitioning, skipping duplicate ended event');
                return;
            }
            
            console.log('Audio ended, transitioning to next track...');
            isTransitioning = true;
            
            try {
                await nextTrack();
                if (!isRepeat) {
                    // If repeat is off and we've reached the end, stop playback
                    const response = await fetch('/api/now-playing');
                    const data = await response.json();
                    if (data.error) {
                        audioPlayer.pause();
                        audioPlayer.src = '';
                        updatePlayPauseIcon();
                    }
                }
            } catch (error) {
                console.error('Error during track transition:', error);
                // If next track fails, try again after a delay
                setTimeout(nextTrack, 1000);
            } finally {
                // Reset transition flag after a short delay to ensure complete cleanup
                setTimeout(() => {
                    isTransitioning = false;
                }, 500);
            }
        });

        // Remove early transition trigger and only use 'ended' event

        // Add click handler for play/pause icon
        document.getElementById('playPauseIcon').addEventListener('click', togglePlay);

        // Start continuous playback when window loads
        window.addEventListener('load', startContinuousPlayback);

        // Enhanced error handling for audio
        audioPlayer.addEventListener('error', (e) => {
            const error = audioPlayer.error;
            let errorMessage = 'Unknown error';
            
            if (error) {
                switch (error.code) {
                    case MediaError.MEDIA_ERR_ABORTED:
                        errorMessage = 'Playback aborted by user';
                        break;
                    case MediaError.MEDIA_ERR_NETWORK:
                        errorMessage = 'Network error while loading media';
                        break;
                    case MediaError.MEDIA_ERR_DECODE:
                        errorMessage = 'Media decoding error';
                        break;
                    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMessage = 'Media format not supported';
                        break;
                }
                console.error('Audio error:', errorMessage, error.message);
                
                // Try to recover by reloading the current track
                if (error.code === MediaError.MEDIA_ERR_NETWORK) {
                    console.log('Attempting to recover from network error...');
                    setTimeout(async () => {
                        try {
                            await updateNowPlaying();
                        } catch (err) {
                            console.error('Recovery failed:', err);
                        }
                    }, 2000);
                }
            } else {
                console.error('Audio error event without error details:', e);
            }
        });

        function savePlaylistState() {
            fetch('/api/save-state', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Playlist state saved:', data);
                    // Flash the save icon to indicate success
                    const saveIcon = document.querySelector('.fa-save');
                    saveIcon.style.color = '#0d6efd';
                    setTimeout(() => {
                        saveIcon.style.color = 'white';
                    }, 500);
                })
                .catch(error => console.error('Error saving playlist state:', error));
        }
    </script>
</body>
</html>
